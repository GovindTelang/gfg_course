// Q1. K-th Bit is Set or Not
/* Given a number n and a bit number k, check if the kth index bit of n is set or not. A bit is called set if it is 1. The position of set bit '1' should be indexed starting with 0 from the LSB side in the binary representation of the number.
Note: Index is starting from 0. You just need to return true or false. */

class Solution
{
    public:
    // Function to check if Kth bit is set or not.
    bool checkKthBit(int n, int k)
    {
        return (1&(n>>k));
        // Your code here
        // It can be a one liner logic!! Think of it!!
    }
};


// Q2. First Set Bit
/*Given an integer n. The task is to return the position of the first set bit found from the right side in the binary representation of the number.
Note: If there is no set bit in the integer N, then return 0 from the function. */

class Solution
{
    public:
    //Function to find position of first set bit in the given number.
    unsigned int getFirstSetBit(int n)
    {
        if(n==0) return n;
        int count=0;
        while(n>0)
        { count++;
        if ((1&n)==1)  return count;
        n=n/2;
        }
        return 0;
        // Your code here
    }
};


//Q3. Count total set bits
/*You are given a number n. Find the total count of set bits for all numbers from 1 to n (both inclusive).
*/
class Solution{
    public:
    // n: input to count the number of set bits
    //Function to return sum of count of set bits in the integers from 1 to n.
    int countSetBits(int n)
    { 
        int c = log2(n);
     
     if(n<=1) return n;
     return pow(2,c-1)*c + (n+1-pow(2,c)) + countSetBits(n-pow(2,c));
     // Your logic here
    }
};


//Q4. Power of 2
//Given a non-negative integer n. The task is to check if it is a power of 2. 
class Solution{
    public:
    // Function to check if given number n is a power of two.
    bool isPowerofTwo(long long n){
        return (n != 0) && ((n & (n - 1)) == 0);
        // Your code here    
        
    }
};


//Q5. Rightmost different bit
/*Given two numbers m and n. The task is to find the position of the rightmost different bit in the binary representation of numbers. If both m and n are the same then return -1 in this case.
Input: m = 11, n = 9
Output: 2
Explanation: Binary representation of the given numbers are: 1011 and 1001, 2nd bit from right is different.*/

class Solution
{
    public:
    //Function to find the first position with different bits.
    int posOfRightMostDiffBit(int m, int n)
    {
        int c = m^n;
        int count = 0;
        if(c==0) return -1;
        while ((c&1)==0)
        {
         count++;
         c=c/2;
        }
        return count+1 ;
        // Your code here
    }
};


//Q6. Bit Difference
 /*You are given two numbers a and b. The task is to count the number of bits needed to be flipped to convert a to b.*/
class Solution{
    public:
    // Function to find number of bits needed to be flipped to convert A to B
    int countBitsFlip(int a, int b){
        int c=a^b;
        if(c==0) return 0;
        int count=0;
        while(c>0)
        { if((c&1)==1) 
          {count++;}
          c=c/2;
        }
        // Your logic here
      return count;  
    }
};


//Q7. Swap all odd and even bits
/*Given an unsigned integer N. The task is to swap all odd bits with even bits. For example, if the given number is 23 (00010111), it should be converted to 43(00101011). Here, every even position bit is swapped with an adjacent bit on the right side(even position bits are highlighted in the binary representation of 23), and every odd position bit is swapped with an adjacent on the left side.
Input: N = 23
Output: 43
Explanation: 
Binary representation of the given number 
is 00010111 after swapping 
00101011 = 43 in decimal.*/

class Solution
{
    public:
    //Function to swap odd and even bits.
    unsigned int swapBits(unsigned int n)
    { unsigned int evenbit = 0xAAAAAAAA; 
      unsigned int oddbit = 0x55555555;
      evenbit = n&evenbit;
      oddbit = n&oddbit;
      evenbit >>= 1;
      oddbit <<= 1;
      return (evenbit|oddbit);
    	// Your code here
    }
};


//Q8. Longest Consecutive 1's
//Given a number N. Find the length of the longest consecutive 1s in its binary representation.

class Solution
{
    public:
    int maxConsecutiveOnes(int N)
    {   int count=0;
        while(N>0)
        {
            N=(N&(N<<1));
            count++;
        }
        return count;
        // code here
    }
};


//Q9. Maximum AND Value
/*Given an array arr[] of N positive elements. The task is to find the Maximum AND Value generated by any pair(arri, arrj) from the array such that i != j.
Note: AND is bitwise '&' operator.
Input: 
N = 4
arr[] = {4, 8, 12, 16}
Output: 8
Explanation:
Pair (8,12) has the Maximum AND Value 8.
*/
class Solution
{
    public:
    // Function for finding maximum AND value.
    int maxAND (int arr[], int n)
    {
       int mx = *max_element(arr,arr+n);
	    int len = log2(mx)+1, num = 1<<len, ans = 0;
	    while(num){
	        int cnt = 0, val = num|ans;
	        for(int i=0; i<n; i++){
	            if((val&arr[i]) == val)
	                cnt += 1;
	            if(cnt == 2)
	                break;
	        }
	        if(cnt == 2)
	            ans |= num;
	        num = num>>1;
	    }
	    return ans;
    }
};


//Q10. Number is sparse or not
/*Given a number N. The task is to check whether it is sparse or not. A number is said to be a sparse number if no two or more consecutive bits are set in the binary representation.*/
class Solution
{
    public:
    //Function to check if the number is sparse or not.
    bool isSparse(int n)
    {
        if((n&(n>>1))==0)
        return 1;
    return 0;
        
        // Your code
    }
};


//Q11. Binary To Gray Code equivalent
/*You are given a decimal number N. You need to find the gray code of the number N and convert it into decimal.*/
class Solution{
    public:
    //  Function to find the gray code of given number n
    int greyConverter(int n)
    {
        return (n^(n>>1));
        // Your code here
        
    }
};


//Q12. Gray to Binary equivalent
/*Given an integer number n, which is a decimal representation of Gray Code. Find the binary equivalent of the Gray Code & return the decimal representation of the binary equivalent
Input: 
n = 4
Output: 
7
Explanation:
Given 4, its gray code =  110.
Binary equivalent of the gray code 110 is 100.
Return 7 representing gray code 100.*/

class Solution{
    public:
    // function to convert a given Gray equivalent n to Binary equivalent.
    int grayToBinary(int n)
    {   int res = n;
        while(n){
            n >>= 1;
            res ^= n;
        }
        return res;
        // Your code here
        
    }
};
